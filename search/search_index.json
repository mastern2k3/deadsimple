{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview deadsimple was created to replicate the simplicity of FastAPI 's dependency injection mechanisms outside of the web framework's context. It also adds a few features I was missing during development as special use cases began to emerge. An additional goal of this project is to provide example design patterns that worked well for me using FastAPI's DI and describe them extensively. Basic usage from dataclasses import dataclass from deadsimple import Depends , resolve @dataclass class DepA (): dep_b : DepB @dataclass class DepB (): value : str def get_dep_b () -> DepB : return DepB ( value = \"some val\" ) def get_dep_a ( dep_b : DepB = Depends ( get_dep_b )) -> DepA : return DepA ( dep_b = dep_b ) my_a = resolve ( get_dep_a ) assert my_a . dep_b . value == \"some val\" Dependencies will instantiate once per factory for each call to resolve . @dataclass class DepC (): dep_a : DepA dep_b : DepB def get_dep_c ( dep_a : DepA = Depends ( get_dep_a ), dep_b : DepB = Depends ( get_dep_b ), ) -> DepC : return DepC ( dep_a = dep_a , dep_b = dep_b ) my_c = resolve ( get_dep_c ) assert my_c . dep_b is my_c . dep_a . dep_b Singleton For Singleton use lru_cache or cache from functools from functools import lru_cache # or from functools import cache if you're 3.9+ @dataclass class Singleton (): pass @dataclass class NotSingleton (): singleton_dep : Singleton @lru_cache def get_singleton () -> Singleton : return Singleton () def get_not_singleton ( singleton : Singleton = Depends ( get_singleton )) -> NotSingleton : return NotSingleton ( singleton_dep = singleton ) not_singleton_a = resolve ( get_not_singleton ) not_singleton_b = resolve ( get_not_singleton ) assert not_singleton_a is not not_singleton_b assert not_singleton_a . singleton_dep is not_singleton_b . singleton_dep Overriding dependencies override_dep_b = DepB ( value = \"some other val\" ) my_a = resolve ( get_dep_a , overrides = { get_dep_b : override_dep_b }) assert my_a . dep_b . value == \"some other val\" Generator factories def get_dep_b () -> DepB : print ( \"enter b\" ) yield DepB ( value = \"some val\" ) print ( \"exit b\" ) def get_dep_a ( dep_b : DepB = Depends ( get_dep_b )) -> DepA : print ( \"enter a\" ) yield DepA ( dep_b = dep_b ) print ( \"exit a\" ) resolve ( get_dep_a ) # prints: # enter b # enter a # exit a # exit b Lazy resolution from deadsimple import Lazy def get_dep_b () -> DepB : print ( \"enter b\" ) return DepB ( value = \"some val\" ) def get_dep_a ( dep_b = Lazy ( get_dep_b )) -> DepA : print ( \"enter a\" ) return DepA ( dep_b = dep_b . lazy ) resolve ( get_dep_a ) # prints: # enter a # enter b Controlled lifetime scope from deadsimple import resolve_open def get_dep_b () -> DepB : print ( \"enter b\" ) yield DepB ( value = \"some val\" ) print ( \"exit b\" ) with resolve_open ( get_dep_b ) as dep_b : print ( \"inside\" ) # prints: # enter b # inside # exit b Installation pip install deadsimple","title":"Overview"},{"location":"#overview","text":"deadsimple was created to replicate the simplicity of FastAPI 's dependency injection mechanisms outside of the web framework's context. It also adds a few features I was missing during development as special use cases began to emerge. An additional goal of this project is to provide example design patterns that worked well for me using FastAPI's DI and describe them extensively.","title":"Overview"},{"location":"#basic-usage","text":"from dataclasses import dataclass from deadsimple import Depends , resolve @dataclass class DepA (): dep_b : DepB @dataclass class DepB (): value : str def get_dep_b () -> DepB : return DepB ( value = \"some val\" ) def get_dep_a ( dep_b : DepB = Depends ( get_dep_b )) -> DepA : return DepA ( dep_b = dep_b ) my_a = resolve ( get_dep_a ) assert my_a . dep_b . value == \"some val\" Dependencies will instantiate once per factory for each call to resolve . @dataclass class DepC (): dep_a : DepA dep_b : DepB def get_dep_c ( dep_a : DepA = Depends ( get_dep_a ), dep_b : DepB = Depends ( get_dep_b ), ) -> DepC : return DepC ( dep_a = dep_a , dep_b = dep_b ) my_c = resolve ( get_dep_c ) assert my_c . dep_b is my_c . dep_a . dep_b","title":"Basic usage"},{"location":"#singleton","text":"For Singleton use lru_cache or cache from functools from functools import lru_cache # or from functools import cache if you're 3.9+ @dataclass class Singleton (): pass @dataclass class NotSingleton (): singleton_dep : Singleton @lru_cache def get_singleton () -> Singleton : return Singleton () def get_not_singleton ( singleton : Singleton = Depends ( get_singleton )) -> NotSingleton : return NotSingleton ( singleton_dep = singleton ) not_singleton_a = resolve ( get_not_singleton ) not_singleton_b = resolve ( get_not_singleton ) assert not_singleton_a is not not_singleton_b assert not_singleton_a . singleton_dep is not_singleton_b . singleton_dep","title":"Singleton"},{"location":"#overriding-dependencies","text":"override_dep_b = DepB ( value = \"some other val\" ) my_a = resolve ( get_dep_a , overrides = { get_dep_b : override_dep_b }) assert my_a . dep_b . value == \"some other val\"","title":"Overriding dependencies"},{"location":"#generator-factories","text":"def get_dep_b () -> DepB : print ( \"enter b\" ) yield DepB ( value = \"some val\" ) print ( \"exit b\" ) def get_dep_a ( dep_b : DepB = Depends ( get_dep_b )) -> DepA : print ( \"enter a\" ) yield DepA ( dep_b = dep_b ) print ( \"exit a\" ) resolve ( get_dep_a ) # prints: # enter b # enter a # exit a # exit b","title":"Generator factories"},{"location":"#lazy-resolution","text":"from deadsimple import Lazy def get_dep_b () -> DepB : print ( \"enter b\" ) return DepB ( value = \"some val\" ) def get_dep_a ( dep_b = Lazy ( get_dep_b )) -> DepA : print ( \"enter a\" ) return DepA ( dep_b = dep_b . lazy ) resolve ( get_dep_a ) # prints: # enter a # enter b","title":"Lazy resolution"},{"location":"#controlled-lifetime-scope","text":"from deadsimple import resolve_open def get_dep_b () -> DepB : print ( \"enter b\" ) yield DepB ( value = \"some val\" ) print ( \"exit b\" ) with resolve_open ( get_dep_b ) as dep_b : print ( \"inside\" ) # prints: # enter b # inside # exit b","title":"Controlled lifetime scope"},{"location":"#installation","text":"pip install deadsimple","title":"Installation"},{"location":"class_dependencies/","text":"Classes as factories Although discouraged, deadsimple supports classes as dependency factories. So the following is possible: from dataclasses import dataclass from deadsimple import Depends , resolve @dataclass class DepB : value : str = \"some val\" @dataclass class DepA : dep_b : DepB = Depends ( DepB ) @dataclass class DepC : dep_a : DepA = Depends ( DepA ) dep_b : DepB = Depends ( DepB ) dep = resolve ( DepC ) assert dep . dep_b . value == \"some val\" assert dep . dep_b is dep . dep_a . dep_b The problem being that using class names to define dependencies doesn't leave room to add logic to the way it is instantiated, e.g. making it singleton, scoped or adding some initialization logic. There is a compromise if you want to avoid wiring all the parameters from the factory into the new instance. Simply declare the factory as an alias to the class name: @dataclass class DepB : value : str = \"some val\" get_dep_b = DepB @dataclass class DepA : dep_b : DepB = Depends ( get_dep_b ) get_dep_a = DepA @dataclass class DepC : dep_a : DepA = Depends ( get_dep_a ) dep_b : DepB = Depends ( get_dep_b ) get_dep_c = DepC dep = resolve ( get_dep_c ) This allows you to later make changes like: @dataclass class DepA : dep_b : DepB def open ( self ): ... def close ( self ): ... def get_dep_a ( dep_b = Depends ( get_dep_b )) -> DepA : dep_a = DepA ( dep_b = dep_b ) try : dep_a . open () yield dep_a finally : dep_a . close () Without going back and changing all instances of Depends(...) .","title":"Classes as factories"},{"location":"class_dependencies/#classes-as-factories","text":"Although discouraged, deadsimple supports classes as dependency factories. So the following is possible: from dataclasses import dataclass from deadsimple import Depends , resolve @dataclass class DepB : value : str = \"some val\" @dataclass class DepA : dep_b : DepB = Depends ( DepB ) @dataclass class DepC : dep_a : DepA = Depends ( DepA ) dep_b : DepB = Depends ( DepB ) dep = resolve ( DepC ) assert dep . dep_b . value == \"some val\" assert dep . dep_b is dep . dep_a . dep_b The problem being that using class names to define dependencies doesn't leave room to add logic to the way it is instantiated, e.g. making it singleton, scoped or adding some initialization logic. There is a compromise if you want to avoid wiring all the parameters from the factory into the new instance. Simply declare the factory as an alias to the class name: @dataclass class DepB : value : str = \"some val\" get_dep_b = DepB @dataclass class DepA : dep_b : DepB = Depends ( get_dep_b ) get_dep_a = DepA @dataclass class DepC : dep_a : DepA = Depends ( get_dep_a ) dep_b : DepB = Depends ( get_dep_b ) get_dep_c = DepC dep = resolve ( get_dep_c ) This allows you to later make changes like: @dataclass class DepA : dep_b : DepB def open ( self ): ... def close ( self ): ... def get_dep_a ( dep_b = Depends ( get_dep_b )) -> DepA : dep_a = DepA ( dep_b = dep_b ) try : dep_a . open () yield dep_a finally : dep_a . close () Without going back and changing all instances of Depends(...) .","title":"Classes as factories"},{"location":"patterns/conditional_dependencies/","text":"Conditional dependencies Some logic require dependencies only under specific cases. Use lazy dependency declarations when you want to avoid resolution until it is absolutely necessary: from deadsimple import Lazy class DoorUnlocker : def unlock ( self , door ): ... def get_door_unlocker (): return DoorUnlocker () class DoorOpener : door_unlocker = Lazy ( get_door_unlocker ) def open_door ( self , door ): if door . is_locked : self . door_unlocker . lazy . unlock ( door ) door . turn_handle () door . push () This way get_door_unlocker and DoorUnlocker are called and instantiated only if door.is_locked .","title":"Conditional dependencies"},{"location":"patterns/conditional_dependencies/#conditional-dependencies","text":"Some logic require dependencies only under specific cases. Use lazy dependency declarations when you want to avoid resolution until it is absolutely necessary: from deadsimple import Lazy class DoorUnlocker : def unlock ( self , door ): ... def get_door_unlocker (): return DoorUnlocker () class DoorOpener : door_unlocker = Lazy ( get_door_unlocker ) def open_door ( self , door ): if door . is_locked : self . door_unlocker . lazy . unlock ( door ) door . turn_handle () door . push () This way get_door_unlocker and DoorUnlocker are called and instantiated only if door.is_locked .","title":"Conditional dependencies"}]}